namespace ToucanServices.Data.Versioning
{
    public class Version : IComparable<Version>
    {
        /* Versioning */

        /// <summary>
        /// The Version class acts differently based off of which type this is set to. 
        /// </summary>
        public VersioningType VersioningType { get; private set; }

        /* Semantic Version */

        /// <summary>
        /// **Semantic Version Variable**
        /// 
        /// The version prefix of the version. This string represents the part of the version which is at the very start.
        /// The version prefix is often just a simple 'v'. One important thing to note is that this string does not 
        /// accept numbers so it will throw an error if the regular expression generated by ChatGPT detects any.
        /// 
        /// VersionPrefix is not a part of the evalutaion process.
        /// 
        /// This variable is NOT REQUIRED to ever be populated and you should be able to leave this empty without ever 
        /// recieving errors because of it.
        /// </summary>
        public string VersionPrefix { get; private set; }

        /// <summary>
        /// **Semantic Version Variable**
        /// 
        /// An array of version numbers that make up the semantic version number, including major, minor, and patch numbers.
        /// The number of version parts can vary depending on the software, but typically there are three numbers.
        /// Some software may use four or more numbers, but this format may not follow the semantic versioning convention.
        /// 
        /// The version numbers are evaluated from left to right to determine the highest version. If two versions have the
        /// same version numbers, the one with no version identifier or build metadata is considered the highest version.
        /// 
        /// This variable is REQUIRED to be populated if this.VersioningType is equal to Semantic, if not, this value 
        /// will never be used, referenced or needed and that means that it should never throw errors.
        /// </summary>
        public uint[] VersionParts { get; private set; }

        /// <summary>
        /// **Semantic Version Variable**
        /// 
        /// A string that represents the pre-release version identifier, which is added after the version numbers in a 
        /// semantic version number. For example, the string "alpha" or "beta" could be used as a version identifier to 
        /// indicate that the software is in a pre-release or testing phase. The version identifier is included in a full 
        /// semantic version number along with the version numbers and build metadata, with a hyphen (-) separating the 
        /// version identifier from the version numbers and a plus sign (+) separating the version numbers from the 
        /// build metadata.
        /// 
        /// This variable is NOT REQUIRED to ever be populated and you should be able to leave this empty without ever 
        /// recieving errors because of it.
        /// </summary>
        public string VersionIdentifier { get; private set; }


        /// <summary>
        /// **Semantic Version Variable**
        /// 
        /// A string that represents build metadata for the software package. Build metadata provides additional information
        /// about the build process or environment, such as the date of the build or the commit hash in the source control system.
        /// The build metadata is included in a full semantic version number along with the version numbers and version
        /// identifier, with a plus sign (+) separating the version numbers from the build metadata.
        ///         
        /// This variable is NOT REQUIRED to ever be populated and you should be able to leave this empty without ever 
        /// recieving errors because of it.
        /// </summary>
        public string BuildMetadata { get; private set; }

        /* Arbitrary Version */

        /// <summary>
        /// **Arbitrary Version Variable**
        /// A string representing the version of the Version class. This string can contain virually anything. Using 
        /// the arbitrary version type instead of the normal semantic one is something you rarely want to do 
        /// except for if you are spacedock.info/mod/1461, then its for some reason accepted to do. 
        /// 
        /// Evaluated can only be done if this.Date is also set to something, if it isnt the CompareTo() function 
        /// of the Version class will just return 0(well not exactly, if you want more information read this.Date's 
        /// summary).
        /// 
        /// This variable is REQUIRED to be populated if this.VersioningType is equal to Arbitrary, if not, this value 
        /// will never be used, referenced or needed and that means that it should never throw errors.
        /// </summary>
        public string ArbitraryVersion { get; private set; }

        /// <summary>
        /// **Arbitrary Version Variable**
        /// DateTimeOffset which should represent when the version was created/published/etc.
        /// 
        /// This variable is NOT REQUIRED to ever be populated and you should be able to leave this empty without ever 
        /// recieving errors because of it.
        /// </summary>
        public DateTimeOffset Date { get; private set; }

        /// <summary>
        /// The constructor sets the variables to the class, but runs some checks before and after. !THIS IS THE LAST 
        /// TIME YOU WILL BE ABLE TO MODIFY THE VARIABLES OF THIS STRUCT SO MAKE SURE YOU ARE HAPPY WITH THEM!         
        /// !ALSO IF YOUR TYPE IS SET TO ARBITRARY NONE OF THE VALUES FOR SEMANTIC WILL BE SET!
        /// </summary>
        /// <param name="CreateInfo"></param>
        public Version(VersionCreateInfo CreateInfo)
        {
            if (CreateInfo.VersioningType == VersioningType.Semantic)
            {
                // Since we only set the values related to the verisoning type we only set the semantic version types here
                VersionPrefix = CreateInfo.VersionPrefix; // Is allowed to be null or empty
                VersionParts = CreateInfo.VersionParts.Length > 0 ? CreateInfo.VersionParts
                    : throw new ArgumentNullException("CreateInfo.VersionParts.Length is not bigger than 0 meaning there are no version parts. No version parts, no version."); // Not allowed to be empty
                VersionIdentifier = CreateInfo.VersionIdentifier; // Can be null
                BuildMetadata = CreateInfo.BuildMetadata;

                // And set the rest to empty, null or whatever I am doing with that date value.
                ArbitraryVersion = "";
                Date = DateTimeOffset.MinValue;
            }
            else if (CreateInfo.VersioningType == VersioningType.Arbitrary)
            {
                // Since we only set the values related to the verisoning type we only set the arbitrary version types here
                ArbitraryVersion = string.IsNullOrEmpty(ArbitraryVersion) ? CreateInfo.ArbitraryVersion
                    : throw new Exception("CreateInfo.ArbitraryVersion is null or emtpy, you kinda need a verison to set a verison, no? " + CreateInfo.ArbitraryVersion);
                Date = CreateInfo.Date;

                // And set the rest to empty or null.
                VersionPrefix = string.Empty;
                VersionParts = new uint[0];
                VersionIdentifier = string.Empty;
                BuildMetadata = string.Empty;
            }
            else throw new ArgumentException("CreateInfo does not contain a corrent VersioningType");
        }

        /// <summary>
        /// Makes it easier to print which version you are working on. It is also helpful 
        /// when debugging as it will show the tostring() return as the type instead of... 
        /// the type...
        /// </summary>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        public override string ToString()
        {
            if (VersioningType == VersioningType.Semantic)
            {
                string VersionString = VersionPrefix;
                VersionString = string.Join(".", VersionParts);
                if (!string.IsNullOrEmpty(VersionIdentifier)) VersionString += $"-{VersionIdentifier}";

                if (!string.IsNullOrEmpty(BuildMetadata)) VersionString += $"+{BuildMetadata}";

                return VersionString;
            }
            else if (VersioningType == VersioningType.Arbitrary)
            {
                return ArbitraryVersion;
            }
            else throw new ArgumentException("This should not be possible, but you managed to have an unsupported versioning type.");
        }

        /// <summary>
        /// This function is the function that is used by a various of different sorters 
        /// for comapring versions. If the function returns a one this will be moved up 
        /// and the other down, and vice versa with -1. If this returns a 0 none will move.
        /// There should never be a case where a semantic verison gets compared to a stringed 
        /// one, but we do have to have edge cases in place.
        /// 
        /// This is the evaluation process explained:
        /// 
        ///     _> If only one of the versions is a semantic verison it wins
        ///     
        ///     _> If both is semantic we evaluate it how semvers are evaluated
        ///     
        ///     _> If none is semantic we check if both versions has a populated date variable
        ///             -> If only one has a date the one with the date wins
        ///             -> If both has a date the one with the earliest date wins
        ///             -> If neither has a date they nobody win and 0 gets returned.
        ///             
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public int CompareTo(Version other)
        {
            // If the versions is not alike, if this is semantic it wins, if not, it doesnt.
            if (VersioningType != other.VersioningType) return VersioningType == VersioningType.Semantic ? 1 : -1;

            // Now either both versions are semantic or arbitrary
            if (VersioningType == VersioningType.Semantic)
            {
                for (int i = 0; i < VersionParts.Length; i++)
                {
                    int CompareValue = (int)(VersionParts[i] - other.VersionParts[i]); // Create a comparison value if this.VP[i] is 1 and other.VP[i] is 2 will the comparison result in -1
                    if (CompareValue == 0) { continue; } // The version parts are the same so we move on to the next version number
                    else { return CompareValue; } // Since the compare value already tells us which one is larger (negative if other is larger and positive if this is larger, and by larger i mean higher verison)
                }
                // All of the version numbers are alike so we check the length of the version identifier. The one with the shortest identifier wins.
                return VersionIdentifier.Length - other.VersionIdentifier.Length;
            }
            else if (VersioningType == VersioningType.Arbitrary)
            {
                return DateTimeOffset.Compare(Date, other.Date);
            }
            else throw new ArgumentException("This should not be possible, but you managed to have an unsupported versioning type.");
        }
    }
}
